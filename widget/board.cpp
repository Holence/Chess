#include "board.h"
#include <QDialog>
#include <QGridLayout>

const QMap<Piece_Type, QString> Board::WhiteIcon = {
    {Piece_Type::king, ":/img/wk.png"},
    {Piece_Type::rook, ":/img/wr.png"},
    {Piece_Type::queen, ":/img/wq.png"},
    {Piece_Type::knight, ":/img/wn.png"},
    {Piece_Type::bishop, ":/img/wb.png"},
    {Piece_Type::pawn, ":/img/wp.png"},
};

const QMap<Piece_Type, QString> Board::BlackIcon = {
    {Piece_Type::king, ":/img/bk.png"},
    {Piece_Type::rook, ":/img/br.png"},
    {Piece_Type::queen, ":/img/bq.png"},
    {Piece_Type::knight, ":/img/bn.png"},
    {Piece_Type::bishop, ":/img/bb.png"},
    {Piece_Type::pawn, ":/img/bp.png"},
};

Board::Board(QWidget *parent, Piece_Color selfColor, bool isPlayingMode)
    : QWidget(parent), engine() {

    this->selfColor = selfColor;

    // draw board
    setFixedSize(QSize(800, 800));
    setObjectName("Board");
    setStyleSheet("#Board{border-image: url(:/img/bg.png) 0 0 0 0 stretch stretch;}");
    // Ëá™ÂÆö‰πâWidgetÁöÑqssËøòÂæóÂä†‰∏äËøô‰∏™ÊâçËÉΩÁîüÊïà
    setAttribute(Qt::WA_StyledBackground, true);

    QGridLayout *grid = new QGridLayout(this);
    grid->setMargin(0);
    grid->setSpacing(0);
    setLayout(grid);

    // dynamic add CellButton
    cellArray = new CellButton *[64];
    for (int x = 1; x <= 8; x++) {
        for (int y = 1; y <= 8; y++) {
            Position pos{x, y};
            CellButton *btn = new CellButton(pos);
            // Êí≠ÊîæreplayÁöÑËØùÔºåÁÇπÂáªÊ£ãÁõò‰∏çÁî®‰∫íÂä®
            if (isPlayingMode) {
                connect(btn, &CellButton::leftClicked, this, &Board::cellSelected);
                connect(btn, &CellButton::rightClicked, this, &Board::cellCanceled);
            }
            grid->addWidget(btn, 8 - y, x - 1);
            cellArray[pos.toIndex()] = btn;
        }
    }

    if (selfColor == Piece_Color::Black)
        boardFilpped = true;
    else
        boardFilpped = false;

    mediaPlayer = new QMediaPlayer(this);

    drawBoard();

    playMedia("qrc:/sound/game-start.mp3");
}

Board::~Board() {
    cellCanceled();
    for (int i = 0; i < 64; i++) {
        cellArray[i]->deleteLater();
    }
    delete cellArray;
}

/**
 * Âçï‰∫∫Ê®°ÂºèË¶ÅËΩÆËΩ¨ÊéßÂà∂ÈªëÁôΩÂèåÊñπ
 */
void Board::flipSelfColor() {
    selfColor = flipPieceColor(selfColor);
}

/**
 * ReplayÊ®°Âºè„ÄÅËÅîÊú∫Ê®°Âºè‰º†ÂÖ•boardÔºåËÆ©engineÁßªÂä®Ê£ãÂ≠ê
 *
 * ‰º†ÂÖ•ÁöÑposÈÉΩÊòØÁôΩ‰∏ãÈªë‰∏äÁöÑÊ†áÂáÜposÔºåËøôÈáåÂè™ÈúÄË¶ÅÂØπboardÁªòÂà∂ÁöÑÈÉ®ÂàÜËøõË°åposËΩ¨‰πâ
 * @param pos_from
 * @param pos_to
 * @param promoteType
 */
void Board::movePiece(Movement m) {
    Position pos_from = m.pos_from;
    Position pos_to = m.pos_to;
    Piece *p_move = engine.getPiece(pos_from);
    QString media_path("");

    if (m.promoteType != Piece_Type::null) {
        media_path = "qrc:/sound/promote.mp3";
    }

    // Ê†áÂáÜÈÄö‰ø°
    Piece *p_eaten = engine.movePiece(m);
    if (p_eaten) {
        media_path = "qrc:/sound/capture.mp3";
        emit pieceEaten(p_eaten);
    }

    // boardÈúÄË¶ÅËΩ¨‰πâËøáÁöÑ
    pos_from = translatePos(pos_from);
    pos_to = translatePos(pos_to);

    // Ê∏ÖÁ©∫‰∏äÊ¨°ÁöÑÁóïËøπ
    foreach (CellButton *btn, traceCellList) {
        btn->clearColor();
    }
    traceCellList.clear();
    // ËÆ∞ÂΩïËµ∞‰ΩçÁïô‰∏ãÁöÑÁóïËøπÔºåÁ¨¨‰∏Ä‰∏™ÊòØfromÔºåÁ¨¨‰∫å‰∏™ÊòØto
    traceCellList.append(getCellBtn(pos_from));
    traceCellList.append(getCellBtn(pos_to));

    // Âà∑Êñ∞Ê£ãÁõòÁîªÈù¢
    updateCellIcon(pos_from);
    updateCellIcon(pos_to);
    if (p_move->getType() != Piece_Type::king) {
        // ‰∏∫‰∫ÜÈÇ£ÁãóÂ±éÁöÑEnPassantÔºåÊàë‰πüÊáíÂæóËÆæËÆ°ÂÖ∂‰ªñÊé•Âè£Ôºå‰πü‰∏çÊÉ≥ÊØèÊ¨°ÈÉΩÂØπÊï¥‰∏™Ê£ãÁõòÂÖ®ÈÉ®Âà∑Êñ∞ÔºåËøôÈáåÈ¢ùÂ§ñÂà∑Êñ∞pos_fromÂ∑¶Âè≥‰∏§‰æßÁöÑÊ†ºÂ≠êü§£
        if (pos_from.x > 1)
            updateCellIcon(Position{pos_from.x - 1, pos_from.y});
        if (pos_from.x < 8)
            updateCellIcon(Position{pos_from.x + 1, pos_from.y});
    } else {
        // ËøòÊúâÁéãËΩ¶Êòì‰ΩçÔºåÁõ¥Êé•Âà∑Êñ∞‰∏ÄÊï¥Ë°åÁÆó‰∫Ü
        for (int i = 1; i <= 8; i++) {
            updateCellIcon(Position{i, pos_from.y});
        }
        // ÁéãËΩ¶Êòì‰Ωç
        if (std::abs(pos_to.x - pos_from.x) == 2) {
            media_path = "qrc:/sound/castle.mp3";
        }
    }

    // Ê£ÄÊü•ÊòØÂê¶game over
    GameState state = engine.checkGameState(p_move->getColor());
    if (engine.getBeingCheckmated()) {
        media_path = "qrc:/sound/move-check.mp3";
    }

    if (media_path.isEmpty()) {
        media_path = "qrc:/sound/move-opponent.mp3";
    }

    playMedia(media_path);
    if (state == GameState::WhiteWin or state == GameState::BlackWin or state == GameState::Draw) {
        emit gameEnded(state);
    }

    cellCanceled();
}

void Board::cellSelected(Position pos) {
    CellButton *current_select_btn = getCellBtn(pos);
    QString media_path("");

    // ‰πãÂâçÊúâÈÄâ‰∏≠ÊúâÊïàÁöÑÊ£ãÂ≠ê ‰∏î ÂΩìÂâçÁÇπÁöÑÊòØÂèØË°åÁöÑËµ∞‰ΩçÔºåÂàôÁßªÂä®Ê£ãÂ≠ê
    if (selectedCell and movableCellList.contains(current_select_btn)) {
        Position pos_from = selectedCell->getPos();
        Position pos_to = pos;

        Piece_Type promoteType;
        if (selectedPiece->getType() == Piece_Type::pawn and ((Pawn *)selectedPiece)->isReadyToPromote()) {
            // Pawn Promote
            promoteType = getPawnPromotion();
            media_path = "qrc:/sound/promote.mp3";
        } else {
            promoteType = Piece_Type::null;
        }

        Movement m{translatePos(pos_from), translatePos(pos_to), promoteType};
        Piece *p_eaten = engine.movePiece(m);
        if (p_eaten) {
            media_path = "qrc:/sound/capture.mp3";
            emit pieceEaten(p_eaten);
        }

        // Ê∏ÖÁ©∫‰∏äÊ¨°ÁöÑÁóïËøπ
        foreach (CellButton *btn, traceCellList) {
            btn->clearColor();
        }
        traceCellList.clear();
        // ËÆ∞ÂΩïËµ∞‰ΩçÁïô‰∏ãÁöÑÁóïËøπÔºåÁ¨¨‰∏Ä‰∏™ÊòØfromÔºåÁ¨¨‰∫å‰∏™ÊòØto
        traceCellList.append(getCellBtn(pos_from));
        traceCellList.append(current_select_btn);

        // Âà∑Êñ∞Ê£ãÁõòÁîªÈù¢
        updateCellIcon(pos_from);
        updateCellIcon(pos_to);
        if (selectedPiece->getType() != Piece_Type::king) {
            // ‰∏∫‰∫ÜÈÇ£ÁãóÂ±éÁöÑEnPassantÔºåÊàë‰πüÊáíÂæóËÆæËÆ°ÂÖ∂‰ªñÊé•Âè£Ôºå‰πü‰∏çÊÉ≥ÊØèÊ¨°ÈÉΩÂØπÊï¥‰∏™Ê£ãÁõòÂÖ®ÈÉ®Âà∑Êñ∞ÔºåËøôÈáåÈ¢ùÂ§ñÂà∑Êñ∞pos_fromÂ∑¶Âè≥‰∏§‰æßÁöÑÊ†ºÂ≠êü§£
            if (pos_from.x > 1)
                updateCellIcon(Position{pos_from.x - 1, pos_from.y});
            if (pos_from.x < 8)
                updateCellIcon(Position{pos_from.x + 1, pos_from.y});
        } else {
            // ËøòÊúâÁéãËΩ¶Êòì‰ΩçÔºåÁõ¥Êé•Âà∑Êñ∞‰∏ÄÊï¥Ë°åÁÆó‰∫Ü
            for (int i = 1; i <= 8; i++) {
                updateCellIcon(Position{i, pos_from.y});
            }
            // ÁéãËΩ¶Êòì‰Ωç
            if (std::abs(pos_to.x - pos_from.x) == 2) {
                media_path = "qrc:/sound/castle.mp3";
            }
        }

        // Ê£ÄÊü•ÊòØÂê¶game over
        GameState state = engine.checkGameState(selectedPiece->getColor());
        if (engine.getBeingCheckmated()) {
            media_path = "qrc:/sound/move-check.mp3";
        }

        if (media_path.isEmpty()) {
            media_path = "qrc:/sound/move-self.mp3";
        }
        playMedia(media_path);

        emit pieceMoved(m);
        if (state == GameState::WhiteWin or state == GameState::BlackWin or state == GameState::Draw) {
            emit gameEnded(state);
        }
        cellCanceled();
    }
    // Âê¶ÂàôÂ∞ùËØïÂ±ïÁ§∫ÂèØË°åÁöÑËµ∞‰Ωç
    else {
        cellCanceled();
        selectedPiece = engine.getPiece(translatePos(pos));
        // Â¶ÇÊûúÈÄâ‰∏≠Ê£ãÂ≠ê ‰∏î ÈÄâ‰∏≠‰∫ÜÂ∑±ÊñπÁöÑÊ£ãÂ≠ê
        if (selectedPiece and selectedPiece->getColor() == selfColor) {
            // Ëé∑ÂèñÂèØË°åÁöÑËµ∞‰Ωç
            QList<Position> l = translatePosList(engine.getPossibleMove(translatePos(pos)));
            if (l.isEmpty()) {
                // ÈÄâÁöÑÊ£ãÂ≠êÊ≤°ÊúâÂèØË°åÁöÑËµ∞‰Ωç
                selectedCell = nullptr;
            } else {
                selectedCell = current_select_btn;
                foreach (Position pos, l) {
                    // Ê†á‰∏∫ÁªøËâ≤
                    CellButton *btn = getCellBtn(pos);
                    btn->paintColor(0, 255, 0, 63);
                    movableCellList.append(btn);
                }
            }
        }
    }
}

Piece_Type Board::getPawnPromotion() {
    QMap<Piece_Type, QString> iconMap;
    if (selectedPiece->getColor() == Piece_Color::White)
        iconMap = WhiteIcon;
    else
        iconMap = BlackIcon;

    QDialog *dlg = new QDialog(this, Qt::WindowSystemMenuHint | Qt::WindowTitleHint);
    dlg->setWindowTitle("Pawn Promotion");
    dlg->setStyleSheet("QPushButton{background-color: rgba(0,0,0,0);}");
    QHBoxLayout layout;
    Piece_Type typeArray[] = {Piece_Type::queen, Piece_Type::rook, Piece_Type::knight, Piece_Type::bishop};
    for (int i = 0; i < 4; i++) {
        QPushButton *b = new QPushButton(dlg);
        connect(b, &QPushButton::clicked, dlg, [dlg, i] { dlg->done(i); });
        b->setIconSize(QSize(100, 100));
        b->setFixedSize(QSize(100, 100));
        b->setIcon(QIcon(iconMap.value(typeArray[i])));
        layout.addWidget(b);
    }
    dlg->setLayout(&layout);
    int choose = dlg->exec();
    return typeArray[choose];
}

void Board::cellCanceled() {
    if (selectedCell) {
        selectedCell = nullptr;

        foreach (CellButton *btn, movableCellList) {
            btn->clearColor();
        }
        movableCellList.clear();
    }
    int a = 63;
    foreach (CellButton *btn, traceCellList) {
        // Ê†á‰∏∫ÈªÑËâ≤
        btn->paintColor(255, 255, 0, a);
        a += 64;
    }
}

void Board::updateCellIcon(Position pos) {
    Piece *p = engine.getPiece(translatePos(pos));
    if (p) {
        if (p->getColor() == Piece_Color::White) {
            getCellBtn(pos)->setIcon(QIcon(WhiteIcon.value(p->getType())));
        } else {
            getCellBtn(pos)->setIcon(QIcon(BlackIcon.value(p->getType())));
        }
    } else {
        getCellBtn(pos)->setIcon(QIcon(QString()));
    }
}

CellButton *Board::getCellBtn(Position pos) {
    return cellArray[pos.toIndex()];
}

/**
 * ÂºÄÂßãÊ∏∏ÊàèÁöÑÊó∂ÂÄôÔºåÁªòÂà∂Êï¥‰∏™Ê£ãÁõòÁöÑÊ£ãÂ≠ê
 *
 * ÂÆûÊàò‰∏≠‰∏çÁî®Ëøô‰∏™ÂáΩÊï∞ÔºåÂÆûÊàò‰∏≠Âä®ÊÄÅÂú∞ÁßªÂä®„ÄÅÂà†Èô§Ê£ãÂ≠êÔºàËßÅcellSelected‰∏≠Ë∞ÉÁî®updateCellIcon()Ôºâ
 */
void Board::drawBoard() {
    for (int x = 1; x <= 8; x++) {
        for (int y = 1; y <= 8; y++) {
            updateCellIcon(Position{x, y});
        }
    }
}

void Board::flipBoard() {
    boardFilpped = !boardFilpped;
    drawBoard();

    // ÁøªËΩ¨ÂêéÊåáÂêëÁöÑbtn‰πüË¶ÅÁøªËΩ¨
    if (!traceCellList.isEmpty()) {
        QList<CellButton *> traceCellList_copy = traceCellList;
        traceCellList.clear();
        foreach (CellButton *btn, traceCellList_copy) {
            btn->clearColor();
            traceCellList.append(getCellBtn(btn->getPos().flipSide()));
        }
    }

    cellCanceled();
}

/**
 * Âõ†‰∏∫engineÂíåclientÈó¥ÈÄö‰ø°ÁöÑ„ÄÅreplay‰øùÂ≠òÁöÑposÁªü‰∏ÄÈÉΩÊòØÁôΩ‰∏ãÈªë‰∏äÁöÑÊ†áÂáÜ
 *
 * Âè™Ë¶ÅÊòØ boardÁöÑpos ‰∏é engine/client/replay ‰πãÈó¥ÁöÑÈÄö‰ø° Ôºà‰ªéBoard::pieceMoved()‰ø°Âè∑‰º†Âá∫Âéª„ÄÅ‰ªéBoard::movePiece()‰º†ËøõÊù•ÁöÑÔºâÔºåÈÉΩÈúÄË¶ÅÁªèËøáËøô‰∏™ÂáΩÊï∞ËøõË°åËΩ¨‰πâ
 *
 * ‰ΩÜengine/client/replay‰πãÈó¥ÊòØ‰∏çÁî®ËΩ¨‰πâÁöÑÔºàclientÈÇ£ËæπÁöÑboard‰ºöÂú®Board::movePiece()Ë¥üË¥£ËΩ¨‰πâÔºâ
 * @param pos
 * @return
 */
Position Board::translatePos(Position pos) {
    if (!boardFilpped) {
        return pos;
    } else {
        return pos.flipSide();
    }
}

/**
 * ÂêåtranslatePos
 * @param posList
 * @return
 */
QList<Position> Board::translatePosList(QList<Position> posList) {
    QList<Position> l;
    foreach (Position pos, posList) {
        l.append(translatePos(pos));
    }
    return l;
}

void Board::playMedia(QString path) {
    mediaPlayer->setMedia(QUrl(path));
    mediaPlayer->play();
}
